# Name: .include.mk - include for Makefiles
# Usage: include .include.mk
# Author: Marco Broglia <marco.broglia@mutex.it>
# Date: 2025.10.16

#-----
# vars
#-----

# env

SHELL := /usr/bin/bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

# main

home := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))

project      := $(notdir $(home))
program_name := rclone_sync
program_path := $(home)/bin/$(program_name)

hostname := $(shell hostname)
host     := $(shell hostname -s)
ip       := $(shell hostname -I | awk '{ print $$1 }')

# dirs and files

data   := $(home)/data
stats  := $(data)/stats
status := $(data)/status
usage  := $(data)/usage

logf   := $(home)/log/$(project).log
logrun := $(home)/log/run

tmp    := $(home)/tmp
stop   := $(tmp)/stop

# cmds

rclone   := /bin/rclone
sendmail := /sbin/sendmail

# source root and destination prefix

src_root := [SRC_ROOT]
dst_root := [DST_ROOT]

lpath := $(src_root)

remote  := $(project)
bucket  := [BUCKET]
rpath   := $(remote):$(bucket)$(dst_root)

# rclone

rclone_conf := $(home)/etc/rclone.conf
rclone_list := $(home)/etc/rclone.list

# os

fstype := xfs

# stats

runid := $(shell date +%Y%m%d.%H%M%S)

watch_tries := 100
watch_delay := .05

# email

mail_From := $(project) system [MAIL_FROM]
mail_from := [MAIL_FROM]
mail_To   := $(project) admin [MAIL_TO]
mail_to   := [MAIL_TO]

mail_log := yes

# misc

, := ,
#rclone_v := $(shell rclone version | sed -n '1s/.* v//p')

#----------
# functions
#----------

#
# t() - current epoch (sec.msec)
# usage: $(t) or $(call t)
#

t = $$(date +%s.%3N)

#
# now() - current timestamp (yyyy.mm.dd-hh:mm:ss)
# usage: $(now) or $(call now)
#

now = $$(date +%Y.%m.%d-%H:%M:%S)

#
# at(epoch) â€“ format an epoch (sec.msec -> yyyy.mm.dd-hh:mm:ss)
# usage: $(call at,epoch)
#

at = $$(date -d @$(1) +%Y.%m.%d-%H:%M:%S)

#
# hms() - format delta times (sec.msec)
# usage: $(call hms,t_delta)
#

define hms
$$(awk -v t=$(1) '
    BEGIN {
        s = int(t);
        ms = 1000 * (t - s);
        h = int(s / 3600); s %= 3600;
        m = int(s / 60); s %= 60;
        if (h > 0) printf("%dh%02dm%02d.%03ds", h, m, s, ms);
        else if (m > 0) printf("%dm%02d.%03ds", m, s, ms);
        else printf("%d.%03ds", s, ms)
    }
')
endef

#
# t_delta() - time difference (sec.msec)
# t_delta_hms() - time difference (hms)
# usage: $(call elapsed,t0,t1)
# usage: $(call t_delta_hms,t0,t1)
#

t_delta = $$(awk -v t0=$(1) -v t1=$(2) 'BEGIN { printf("%.3f", t2 - t1) }')
t_delta_hms = $(call hms,$(call t_delta,$(1),$(2)))

#
# log() - timestamped log
# usage: $(call log,message)
#

make := $(notdir $(MAKE))
log = printf "%s [%s(%s):%s] %s\n" $(now) $(make) $@ $$$$ "$(1)" >> $(logf)

#
# relpath() - path relative to home
# usage: $(call relpath,path)
#

relpath = $$(printf "%s" $(1) | sed 's|$(home)/||')

#
# parse_rule() - parse a rule and set key=value
# usage: $(call parse_rule,rule)
#

define parse_rule
rule=$$(printf "%s\n" "$(1)")
relpath=$$(printf "%s\n" "$$rule" | awk '{ print $$1 }')
[ "$$relpath" = "." ] && relpath=
ruleid=$${relpath##*/} opts=
rest=$$(printf "%s\n" "$$rule" | awk '{ $$1 = ""; print }')
set -f; eval "$$rest"; set +f
endef

#
# watch_rclone() - discover rclone_pid and rclone_cmd
# usage: $(watch_rclone)
#

define watch_rclone
(
    rclone_pid=$$($(call watch_child,$$program_pid,rclone, \
        $(strip $(watch_tries)),$(watch_delay)))
    if [ -n "$$rclone_pid" ]; then
        $(call set_status,rclone_pid,$$rclone_pid)
        rclone_cmd=$$($(call get_command_by_pid,$$rclone_pid))
        if [ -n "$$rclone_cmd" ]; then
            $(call write_stat,$$rulef,rclone_cmd,$$rclone_cmd)
            $(call set_status,rclone_cmd,$$rclone_cmd)
        fi
    else
        $(call set_status,rclone_pid,unknown)
    fi
) & watcher_pid=$$!
endef

#
# watch_child() - return pid of a child process
# usage: $(call watch_child,ppid,procname,n_iters,sleep)
#

define watch_child
for _ in {1..$(3)}; do
    child=$$(pgrep -n -P $(1) -x $(2) || true)
    [ -n "$$child" ] && break
    sleep $(4)
done
printf "%s" "$$child"
endef

#
# get_command_by_pid() - get command line by pid from /proc
# usage: $(call get_command_by_pid,pid)
#

define get_command_by_pid
mapfile -d '' -t argv < /proc/$(1)/cmdline
printf -v cmd_q '%q ' "$${argv[@]}"
printf "%s\n" "$${cmd_q% }"
endef

#
# stop_guard() - exit current rule if a stop flag file exists
# usage: $(stop_guard)
#

define stop_guard
if [ -f $(stop) ]; then
    printf "[$(project)] stop flag found: exit after current rule\n"
    rm -f $(stop)
    $(call log,stop flag found: exit after current rule)
    exit 0
fi
endef

#
# write_stat() - write "key: value" to stat file
# usage: $(call write_stat,statfile,key,value)
#

write_stat = $$(printf "%s: %s\n" "$(2)" "$(3)" >> $(1))

#
# set_status() - write "key: value" to (global) status file
# get_status() - read "key: value" from (global) status file
# usage: $(call set_status,key,value)
# usage: $(call get_status,key)
#

define set_status
_k="$(1)" _v="$(2)"
if grep -q "^$$_k:" $(status); then
    sed -Ei "s|^($$_k):.*|\1: $$_v|" $(status)
else
    printf "%s: %s\n" "$$_k" "$$_v" >> $(status)
fi
endef

get_status = $$(sed -En '/^$(1):/s/^[^:]*:[[:space:]]*//p' $(status))

#
# get_rclone_stats() - parse an rclone per-run log and get key/value metrics
# usage: $(call get_rclone_stats,rule_log)
#

define get_rclone_stats
awk '
    function xc(s) { sub(/,$$/,"",s); return s }

    BEGIN { xfer = 0; xfer_new = 0; xfer_replaced = 0; deleted = 0; }

    /^Checks:/                       { checks = $$2 "/" xc($$4) }
    /^Transferred:/ && !/ETA/        { xfer = $$2 "/" xc($$4) }
    /^Transferred:/ && /ETA/         { xfer_size = $$2 $$3 "/" $$5 xc($$6) }
    /Copied \(new\)$$/               { xfer_new++ }
    /Copied \(replaced existing\)$$/ { xfer_replaced++ }
    /^Deleted:/                      { deleted = $$2 }
    /^Elapsed time:/                 { elapsed = $$3 }

    END {
        printf "rclone_checks %s\n",           checks
        printf "rclone_transferred %s\n",      xfer
        printf "rclone_transferred_size %s\n", xfer_size
        printf "rclone_copied_new %s\n",       xfer_new
        printf "rclone_copied_replaced %s\n",  xfer_replaced
        printf "rclone_deleted %s\n",          deleted
        printf "rclone_elapsed %s\n",          elapsed
    }
' $(1)
endef

#
# rclone_stats() - write rclone metrics into the rule stats file and log
# usage: $(call rclone_stats,ruleid,rulef,rule_log)
#

define rclone_stats
declare -A S
while read _k _v; do
    S[$$_k]="$$_v"
    $(call write_stat,$(2),$$_k,$$_v)
done < <($(call get_rclone_stats,$(3)))
printf -v stats_log "checks=%s, transferred=%s (%s) (new=%s, replaced=%s), \
    deleted=%s, elapsed=%s" \
    "$${S[rclone_checks]}" \
    "$${S[rclone_transferred]}" "$${S[rclone_transferred_size]}" \
    "$${S[rclone_copied_new]}" "$${S[rclone_copied_replaced]}" \
    "$${S[rclone_deleted]}" "$${S[rclone_elapsed]}"
$(call log,[$(1)] rclone stats: $$stats_log)
endef

#
# append_rule_log() - append rclone rule log to the main log
# usage: $(call append_rule_log,rule_log)
#

define append_rule_log
{
    printf -- "-- begin rclone log --\n"
    sed '$${/^$$/d}' "$(1)"
    printf -- "-- end rclone log --\n"
} >> $(logf)
endef

#
# trap_on_signal() - signal handler
# usage: $(call trap_on_signal,signal,rc)
#

define trap_on_signal
trap_on_signal() {
    local sig=$1 sigcode=$2
    local rc=$$((128 + sigcode))

    $(call log,(WARN) caught $$sig signal)

    rule_elapsed=$(call t_delta,$$t1,$(t))
    $(call append_rule_log,$$rule_log)
    $(call rclone_stats,$$ruleid,$$rulef,$$rule_log)
    $(call write_stat,$$rulef,rule_ended_at,$(now))
    $(call write_stat,$$rulef,rule_elapsed,$${rule_elapsed}s)
    $(call write_stat,$$rulef,rc,$$rc)
    $(call log,[$$ruleid] (WARN) end '$(program_name)': rc=$$rc \
        (elapsed: $(call hms,$$rule_elapsed)))

    $(call set_status,status,NOT RUNNING (interrupted))
    $(call set_status,program_pid,-)
    $(call set_status,rclone_pid,-)
    $(call set_status,ended_at,$(now))
    $(call set_status,rc,$$rc)
    t0=$(call get_status,start_epoch)
    $(call log,end '$(project)' \
        (total elapsed: $(call t_delta_hms,$$t0,$(t))))

    exit $$rc
}
endef

#
# mib() - rounded MiB
# usage: $(call mib,bytes)
#

mib = $$((($1 + 524288) / 1048576))


# vim: ts=4
