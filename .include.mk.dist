# Name: .include.mk - include for Makefiles
# Usage: include .include.mk
# Author: Marco Broglia <marco.broglia@mutex.it>
# Date: 2025.11.03

#-----
# vars
#-----

# env

SHELL := /usr/bin/bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

# main

home := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))

project      := $(shell basename "$(home)")
version      := 2.0
program_name := rclone_sync
program_path := $(home)/bin/$(program_name)

hostname := $(shell hostname)
ip       := $(shell hostname -I | awk '{ print $$1 }')

# cmds

rclone   := /bin/rclone
sendmail := /sbin/sendmail

# rclone

rclone_conf := $(home)/etc/rclone.conf
rclone_ver  := $(shell rclone version | sed -n '1s/.* v//p')

# dirs and files

data    := $(home)/data
tmp     := $(home)/tmp
stats   := $(data)/stats
reports := $(data)/reports

usage  := $(data)/usage
stop   := $(tmp)/stop

logf   := $(home)/log/$(project).log
logrun := $(home)/log/run

# source/destination, local/remote

src_root := [SRC_ROOT]
dst_root := [DST_ROOT]

lpath := $(src_root)

remote := $(project)
bucket := [BUCKET]
rpath  := $(remote):$(bucket)$(dst_root)

# rules

rules_list   := $(home)/etc/rules.list
ruleids_list := $(home)/etc/ruleids.list

# run

watch_tries := 100
watch_delay := .05

# status

last := $(stats)/last
prev := $(stats)/prev

status := $(last)/.status

rule_width := [RULE_WIDTH]
rule_queue := [RULE_QUEUE]

# email

mail_From := $(project) system [MAIL_FROM]
mail_from := [MAIL_FROM]
mail_To   := $(project) admin [MAIL_TO]
mail_to   := [MAIL_TO]

mail_log := yes

# misc

, := ,

#-----
# time
#-----

#
# t()      - return current epoch (sec.ms)
# t_now()  - return current timestamp (yyyy.mm.dd-hh:mm:ss)
# t_znow() - return current compressed timestamp (yyyymmdd.hhmmss)
# usage: $(t)
# usage: $(t_now)
# usage: $(t_znow)
#

t      = $$(date +%s.%3N)
t_now  = $$(date +%Y.%m.%d-%H:%M:%S)
t_znow = $$(date +%Y%m%d.%H%M%S)

#
# at() - format epoch (sec.ms -> yyyy.mm.dd-hh:mm:ss)
# usage: $(call at,epoch)
#

at = $$(date -d @$$(printf "%.0f" $(1)) +%Y.%m.%d-%H:%M:%S)

#
# t_hms_ms()    - format duration as hms.ms
# t_hms()       - format duration as hms
# t_hms_colon() - format duration as h:m:s
# usage: $(call t_hms_ms,t_delta)
# usage: $(call t_hms,t_delta)
# usage: $(call t_hms_colon,t_delta)
#

define t_hms_ms
$$(
    awk -v t=$(1) '
        BEGIN {
            s = int(t);
            ms = 1000 * (t - s);
            h = int(s / 3600); s %= 3600;
            m = int(s / 60); s %= 60;
            if (h > 0) printf("%dh%02dm%02d.%03ds", h, m, s, ms);
            else if (m > 0) printf("%dm%02d.%03ds", m, s, ms);
            else printf("%d.%03ds", s, ms)
        }'
)
endef

define t_hms
$$(
    awk -v t=$(1) '
        BEGIN {
            s = int(t + .5);
            h = int(s / 3600); s %= 3600;
            m = int(s / 60); s %= 60;
            if (h > 0) printf("%dh%02dm%02ds", h, m, s);
            else if (m > 0) printf("%dm%02ds", m, s);
            else printf("%ds", s)
        }'
)
endef

define t_hms_colon
$$(
    awk -v t=$(1) '
        BEGIN {
            s = int(t + .5);
            h = int(s / 3600); s %= 3600;
            m = int(s / 60); s %= 60;
            printf("%02d:%02d:%02d", h, m, s);
        }'
)
endef

#
# t_delta()        - compute time difference (sec.ms)
# t_delta_hms_ms() - compute time difference (hms.ms)
# t_delta_hms()    - compute time difference (hms)
# usage: $(call t_delta,t0,t1)
# usage: $(call t_delta_hms_ms,t0,t1)
# usage: $(call t_delta_hms,t0,t1)
#

t_delta = $$(awk -v t1=$(1) -v t2=$(2) 'BEGIN { printf("%.3f", t2 - t1) }')
t_delta_hms_ms = $(call t_hms_ms,$(call t_delta,$(1),$(2)))
t_delta_hms = $(call t_hms,$(call t_delta,$(1),$(2)))

#------
# runid
#------

#
# get_runid() - get and validate runid
# usage: $(get_runid)
#

define get_runid
case "$${runid-}" in
    "")   runid=$$(kv_get $(status) runid) ;;
    prev) [ -L "$(prev)" ] && runid=$$(readlink "$(prev)") ;;
    last) [ -L "$(last)" ] && runid=$$(readlink "$(last)") ;;
esac
if [ -d "$(stats)/$$runid" ]; then
    printf "%s" $$runid
    $(call log,runid: '$$runid')
else
    printf "[%s] invalid runid '%s'\n" $(project) $$runid >&2
    $(call log,invalid runid '$$runid')
    exit 1
fi
endef

#---------
# kv store
#---------

#
# define_kv() - define kv_get() and kv_set() shell functions
# kv_set()    - replace key/value (append if missing)
# kv_get()    - get key/value (empty if missing)
# usage: $(define_kv)
#        kv_get file key
#        kv_set file key value
#

define define_kv
kv_set() {
    local f=$$1 k=$$2 v=$$3
    printf -v v "%s" "$$v"
    if grep -q "^$$k:" "$$f"; then
        sed -Ei "s|^$$k:.*|$$k: $$v|" "$$f"
    else
        printf "%s: %s\n" $$k "$$v" >> "$$f"
    fi
}

kv_get() {
    local f=$$1 k=$$2
    sed -En 's/^'$$k':[[:space:]]*//p' "$$f"
}
endef

#--------
# process
#--------

#
# watch_child() - return pid of a child process
# usage: $(call watch_child,ppid,procname,n_iters,sleep)
#

define watch_child
$$(
    for _ in {1..$(3)}; do
        child=$$(pgrep -n -P $(1) -x $(2) || true)
        [ -n "$$child" ] && break
        sleep $(4)
    done
    printf "%s" "$$child"
)
endef

#
# get_command_by_pid() - return command line by pid
# usage: $(call get_command_by_pid,pid)
#

define get_command_by_pid
$$(
    mapfile -d '' -t argv < /proc/$(1)/cmdline
    printf -v cmd "%s " "$${argv[@]}"
    printf "%s" "$${cmd% }"
)
endef

#
# watch_rclone() - discover rclone_pid and rclone_cmd
# usage: $(watch_rclone)
#

define watch_rclone
(
    rclone_pid=$(call
        watch_child,$$program_pid,rclone,$(watch_tries),$(watch_delay))
    if [ -n "$$rclone_pid" ]; then
        kv_set "$(status)" rclone_pid $$rclone_pid
        rclone_cmd=$(call get_command_by_pid,$$rclone_pid)
        if [ -n "$$rclone_cmd" ]; then
            kv_set "$$rulef" rclone_cmd "$$rclone_cmd"
        fi
    else
        kv_set "$(status)" rclone_pid unknown
    fi
) & watcher_pid=$$!
endef

#
# stop_guard() - exit current rule if a stop flag exists
# usage: $(call stop_guard,ruleid)
#

define stop_guard
if [ -f "$(stop)" ]; then
    printf "[%s] stop flag found: exit after current rule (ruleid='%s')\n" \
        $(project) $(1)
    rm -f "$(stop)"
    $(call log,stop flag found: exit after current rule (ruleid='$(1)'))
    kv_set "$(status)" state "NOT RUNNING (stopped)"
    kv_set "$(status)" rc 200
    exit 0
fi
endef

#
# define_trap_on_signal() - define trap_on_signal() shell function
# trap_on_signal()        - handle signals
# usage: $(define_trap_on_signal)
#        trap_on_signal signal rc
#

define define_trap_on_signal
trap_on_signal() {
    local sig=$$1 sigcode=$$2
    local rc=$$((128 + sigcode))

    $(call log,(WARN) caught $$sig signal)

    t2=$(t);
    rule_ended_at=$(call at,$$t2)
    if [ -n "$${t1-}" ]; then
        rule_elapsed=$(call t_delta,$$t1,$$t2)
        rule_elapsed_hms_ms=$(call t_hms_ms,$$rule_elapsed)
    else
        rule_elapsed=
        rule_elapsed_hms_ms=unknown
    fi

    $(call append_rule_log,$$rule_log)
    kv_set "$$rulef" rule_ended_at $$rule_ended_at
    if [ -n "$$rule_elapsed" ]; then
        kv_set "$$rulef" rule_elapsed $$rule_elapsed
    fi
    kv_set "$$rulef" rc $$rc

    kv_set "$(status)" program_pid -
    kv_set "$(status)" rclone_pid -
    $(call log,[$$ruleid] (WARN) end '$(program_name)': rc=$$rc \
        (elapsed: $$rule_elapsed_hms_ms))

    t0=$$(kv_get "$(status)" started_at_epoch)
    t3=$(t)
    kv_set "$(status)" ended_at_epoch $$t3
    kv_set "$(status)" ended_at $(call at,$$t3)
    kv_set "$(status)" total_elapsed $(call t_delta,$$t0,$$t3)
    kv_set "$(status)" state "NOT RUNNING (killed)"
    kv_set "$(status)" rc $$rc

    k=$$(kv_get "$(status)" rules_done)
    $(call log,end '$(project)' (runid=$$runid$(,) rules=$$k/$$n) \
        (total elapsed: $(call t_delta_hms_ms,$$t0,$$t3)))
    exit $$rc
}
endef

#------
# rules
#------

#
# define_parse_rule() - define parse_rule() shell function
# parse_rule()        - parse a rule and set key=value
# usage: $(define_parse_rule)
#        parse_rule rule
#

define define_parse_rule
parse_rule() {
    local rule=$$1
    case "$$rule" in
        *" -- "*) path=$${rule%% -- *} opts=$${rule#* -- } ;;
        *)        path=$$rule opts= ;;
    esac
    [ "$$path" = . ] && path=
    ruleid=$$(printf "%s" "$${path##*/}" | tr '[:space:]' '_')
    set -f; eval "$$opts"; set +f
}
endef

#
# count_rules() - count rules in list
# usage: $(count_rules,rules_list)
#

count_rules = $$(grep -Ev '^[[:space:]]*(\#|$$)' "$(1)" | wc -l)

#------
# stats
#------

#
# get_rclone_stats() - parse rclone log and extract key/value metrics
# usage: $(call get_rclone_stats,rule_log)
#

define get_rclone_stats
awk '
    function xc(s) { sub(/,$$/, "", s); return s }

    BEGIN { xfer = 0; xfer_new = 0; xfer_replaced = 0; deleted = 0; }

    /^Checks:/                       { checks = $$2 "/" xc($$4) }
    /^Transferred:/ && !/ETA/        { xfer = $$2 "/" xc($$4) }
    /^Transferred:/ && /ETA/         { xfer_size = $$2 $$3 "/" $$5 xc($$6) }
    /Copied \(new\)$$/               { xfer_new++ }
    /Copied \(replaced existing\)$$/ { xfer_replaced++ }
    /^Deleted:/                      { deleted = $$2 }
    /^Elapsed time:/                 { elapsed = $$3 }

    END {
        printf "rclone_checks %s\n",           checks
        printf "rclone_transferred %s\n",      xfer
        printf "rclone_transferred_size %s\n", xfer_size
        printf "rclone_copied_new %d\n",       xfer_new
        printf "rclone_copied_replaced %d\n",  xfer_replaced
        printf "rclone_deleted %d\n",          deleted
        printf "rclone_elapsed %s\n",          elapsed
    }
' "$(1)"
endef

#
# rclone_stats() - write rclone metrics to the rule stats file
# usage: $(call rclone_stats,ruleid,rulef,rule_log)
#

define rclone_stats
declare -A S
while read _k _v; do
    S[$$_k]=$$_v
    kv_set "$(2)" $$_k $$_v
done < <($(call get_rclone_stats,$(3)))
printf -v stats_log "checks=%s, transferred=%s (%s) (new=%d, replaced=%d), \
    deleted=%d, elapsed=%s" \
    "$${S[rclone_checks]}" \
    "$${S[rclone_transferred]}" "$${S[rclone_transferred_size]}" \
    "$${S[rclone_copied_new]}" "$${S[rclone_copied_replaced]}" \
    "$${S[rclone_deleted]}" "$${S[rclone_elapsed]}"
$(call log,[$(1)] rclone stats: $$stats_log)
endef

#-------
# status
#-------

#
# get_gstate() - compute global state (running|completed|stopped|killed)
# get_rstate() - compute rule state (done|fail|run|queue)
# usage: $(call get_gstate,status)
# usage: $(call get_rstate,rulef,gstate)
#

define get_gstate
$$(
    state="$(1)"
    if [ "$$state" = RUNNING ]; then
        printf running
    else
        printf "%s" $$(echo "$$state" | sed 's/.*(\(.*\)).*/\1/')
    fi
)
endef

define get_rstate
$$(
    rulef="$(1)" gstate=$(2)
    if [ ! -f "$$rulef" ]; then
        printf queue
    elif rc=$$(kv_get "$$rulef" rc); [ -n "$$rc" ]; then
        printf done
    elif [ $$gstate = running ]; then
        printf run
    else
        printf fail
    fi
)
endef

#--------
# logging
#--------

#
# log() - write timestamped log
# usage: $(call log,message)
#

make := $(shell basename "$(MAKE)")
log = printf "%s [%s(%s):%s] %s\n" $(t_now) $(make) $@ $$$$ "$(1)" >> "$(logf)"

#
# append_rule_log() - append rclone log to the main log
# usage: $(call append_rule_log,rule_log)
#

define append_rule_log
{
    printf -- "-- begin rclone log (ruleid=%s) --\n" $$ruleid
    sed '$${/^$$/d}' "$(1)"
    printf -- "-- end rclone log --\n"
} >> "$(logf)"
endef

#-----------
# formatting
#-----------

#
# truncate() - truncate string to a max length (chars), append '+' if longer
# usage: $(call truncate,string,width)
#

define truncate
$$(
    s=$(1) w=$(2)
    [ $${#s} -le $$w ] && printf "%s" "$$s" || printf "%s+" "$${s:0:$$((n-1))}"
)
endef

#
# iec2mib() - convert IEC size (B, KiB, MiB, GiB, TiB) to MiB (1 decimal)
# usage: $(call mib,size)
#

define mib
$$(
    awk -v s=$(1) '
        function n(x) { sub(/[BKMGTi]*$$/, "", x); return x }
        BEGIN {
            if      (s ~ /[0-9]B/)   print sprintf("%.1f", n(s) / 1048576)
            else if (s ~ /[0-9]KiB/) print sprintf("%.1f", n(s) / 1024)
            else if (s ~ /[0-9]MiB/) print sprintf("%.1f", n(s))
            else if (s ~ /[0-9]GiB/) print sprintf("%.1f", n(s) * 1024)
            else if (s ~ /[0-9]TiB/) print sprintf("%.1f", n(s) * 1048576)
        }'
)
endef

#
# mib2iec() - convert MiB to best IEC unit (B, KiB, MiB, GiB, TiB) (1 decimal)
# usage: $(call mib2iec,mib)
#

define mib2iec
$$(
    awk -v mib=$(1) '
        BEGIN {
            u = split("B KiB MiB GiB TiB", U)
            n = 1048576 * mib
            for (i = 1; n >= 1024 && i < u; i++) n /= 1024
            printf("%.1f %s", n, U[i])
        }'
)
endef

#
# num3() - format integer with 3-digit grouping
# usage: $(call num3,num)
#

num3 = $$(printf "%s" $(1) | sed -E ':a;s/^(-?[0-9]+)([0-9]{3})/\1'\''\2/;ta')

#------
# utils
#------

#
# colors() - initialize ansi colors
# usage: $(colors)
#

define colors
ESC="\033"
if [ -t 1 ]; then
    BLD="$$ESC[1m" RST="$$ESC[0m"

    RED="$$ESC[31m" _RED_="$$ESC[91m"
    GRN="$$ESC[32m" _GRN_="$$ESC[92m"
    YEL="$$ESC[33m" _YEL_="$$ESC[93m"
    BLU="$$ESC[34m" _BLU_="$$ESC[94m"
    MAG="$$ESC[35m" _MAG_="$$ESC[95m"
    CYN="$$ESC[36m" _CYN_="$$ESC[96m"
else
    BLD= RST=
    RED= GRN= YEL= BLU= MAG= CYN=
    _RED_= _GRN_= _YEL_= _BLU_= _MAG_= _CYN_=
fi
endef

#
# relpath() - return path relative to home
# usage: $(call relpath,path)
#

relpath = $$(printf "%s" "$(1)" | sed 's|$(home)/||')


# vim: ts=4
