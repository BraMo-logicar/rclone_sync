# Name: .include.mk - include for Makefiles
# Usage: include .include.mk
# Author: Marco Broglia <marco.broglia@mutex.it>
# Date: 2025.10.20

#-----
# vars
#-----

# env

SHELL := /usr/bin/bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

# main

home := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))

project      := $(notdir $(home))
version      := 2.0
program_name := rclone_sync
program_path := $(home)/bin/$(program_name)

hostname := $(shell hostname)
host     := $(shell hostname -s)
ip       := $(shell hostname -I | awk '{ print $$1 }')

# dirs and files

data   := $(home)/data
stats  := $(data)/stats
status := $(data)/status
usage  := $(data)/usage

logf   := $(home)/log/$(project).log
logrun := $(home)/log/run

tmp    := $(home)/tmp
stop   := $(tmp)/stop

# cmds

rclone   := /bin/rclone
sendmail := /sbin/sendmail

# source root and destination prefix

src_root := [SRC_ROOT]
dst_root := [DST_ROOT]

lpath := $(src_root)

remote  := $(project)
bucket  := [BUCKET]
rpath   := $(remote):$(bucket)$(dst_root)

# rclone

rclone_conf := $(home)/etc/rclone.conf
rclone_ver  := $(shell rclone version | sed -n '1s/.* v//p')

# rules

rules_list   := $(home)/etc/rules.list
ruleids_list := $(home)/etc/ruleids.list

# stats

runid := $(shell date +%Y%m%d.%H%M%S)

watch_tries := 100
watch_delay := .05

# report

rule_width := [RULE_WIDTH]

# email

mail_From := $(project) system [MAIL_FROM]
mail_from := [MAIL_FROM]
mail_To   := $(project) admin [MAIL_TO]
mail_to   := [MAIL_TO]

mail_log := yes

# misc

, := ,

#---------------
# core functions
#---------------

#
# t() - current epoch (sec.ms)
# usage: $(t) or $(call t)
#

t = $$(date +%s.%3N)

#
# now() - current timestamp (yyyy.mm.dd-hh:mm:ss)
# usage: $(now) or $(call now)
#

now = $$(date +%Y.%m.%d-%H:%M:%S)

#
# at(epoch) - format an epoch (sec.ms -> yyyy.mm.dd-hh:mm:ss)
# usage: $(call at,epoch)
#

at = $$(date -d @$(1) +%Y.%m.%d-%H:%M:%S)

#
# hms_ms() - format delta times (hms.ms)
# hms() - format delta times (hms)
# hms_colon() - format delta times (h:m:s)
# usage: $(call hms_ms,t_delta)
# usage: $(call hms,t_delta)
# usage: $(call hms_colon,t_delta)
#

define hms_ms
$$(awk -v t=$(1) '
    BEGIN {
        s = int(t);
        ms = 1000 * (t - s);
        h = int(s / 3600); s %= 3600;
        m = int(s / 60); s %= 60;
        if (h > 0) printf("%dh%02dm%02d.%03ds", h, m, s, ms);
        else if (m > 0) printf("%dm%02d.%03ds", m, s, ms);
        else printf("%d.%03ds", s, ms)
    }
')
endef

define hms
$$(awk -v t=$(1) '
    BEGIN {
        s = int(t);
        h = int(s / 3600); s %= 3600;
        m = int(s / 60); s %= 60;
        if (h > 0) printf("%dh%02dm%02ds", h, m, s);
        else if (m > 0) printf("%dm%02ds", m, s);
        else printf("%ds", s)
    }
')
endef

define hms_colon
$$(awk -v t=$(1) '
    BEGIN {
        s = int(t);
        h = int(s / 3600); s %= 3600;
        m = int(s / 60); s %= 60;
        printf("%02d:%02d:%02d", h, m, s);
    }
')
endef

#
# t_delta() - time difference (sec.ms)
# t_delta_hms_ms() - time difference (hms.ms)
# t_delta_hms() - time difference (hms)
# usage: $(call t_delta,t0,t1)
# usage: $(call t_delta_hms_ms,t0,t1)
# usage: $(call t_delta_hms,t0,t1)
#

t_delta = $$(awk -v t1=$(1) -v t2=$(2) 'BEGIN { printf("%.3f", t2 - t1) }')
t_delta_hms_ms = $(call hms_ms,$(call t_delta,$(1),$(2)))
t_delta_hms = $(call hms,$(call t_delta,$(1),$(2)))

#
# log() - timestamped log
# usage: $(call log,message)
#

make := $(notdir $(MAKE))
log = printf "%s [%s(%s):%s] %s\n" $(now) $(make) $@ $$$$ "$(1)" >> $(logf)

#
# relpath() - path relative to home
# usage: $(call relpath,path)
#

relpath = $$(printf "%s" $(1) | sed 's|$(home)/||')

#
# parse_rule() - parse a rule and set key=value
# usage: $(call parse_rule,rule)
#

define parse_rule
rule=$$(printf "%s\n" "$(1)")
if printf "%s" "$$rule" | grep -q " -- "; then
    path="$${rule%% -- *}" opts="$${rule#* -- }"
else
    path="$$rule" opts=
fi
[ "$$path" = "." ] && path=
ruleid=$$(printf "%s" "$${path##*/}" | tr '[:space:]' '_')
set -f; eval "$$opts"; set +f
endef

#
# watch_rclone() - discover rclone_pid and rclone_cmd
# usage: $(watch_rclone)
#

define watch_rclone
(
    rclone_pid=$$($(call watch_child,$$program_pid,rclone, \
        $(strip $(watch_tries)),$(watch_delay)))
    if [ -n "$$rclone_pid" ]; then
        $(call kv_set,$(status),rclone_pid,$$rclone_pid)
        rclone_cmd=$$($(call get_command_by_pid,$$rclone_pid))
        if [ -n "$$rclone_cmd" ]; then
            $(call kv_set,$$rulef,rclone_cmd,$$rclone_cmd)
            $(call kv_set,$(status),rclone_cmd,$$rclone_cmd)
        fi
    else
        $(call kv_set,$(status),rclone_pid,unknown)
    fi
) & watcher_pid=$$!
endef

#
# watch_child() - return pid of a child process
# usage: $(call watch_child,ppid,procname,n_iters,sleep)
#

define watch_child
for _ in {1..$(3)}; do
    child=$$(pgrep -n -P $(1) -x $(2) || true)
    [ -n "$$child" ] && break
    sleep $(4)
done
printf "%s" "$$child"
endef

#
# get_command_by_pid() - get command line by pid from /proc
# usage: $(call get_command_by_pid,pid)
#

define get_command_by_pid
mapfile -d '' -t argv < /proc/$(1)/cmdline
printf -v cmd "%q " "$${argv[@]}"
printf "%s\n" "$${cmd% }"
endef

#
# stop_guard() - exit current rule if a stop flag file exists
# usage: $(stop_guard)
#

define stop_guard
if [ -f $(stop) ]; then
    printf "[$(project)] stop flag found: exit after current rule\n"
    rm -f $(stop)
    $(call log,stop flag found: exit after current rule)
    exit 0
fi
endef

#
# kv_get() - get key/value (empty if missing)
# kv_set() - replace key/value (append if missing)
# usage: $(call kv_get,file,key)
# usage: $(call kv_set,file,key,value)
#

kv_get = $$(sed -En 's/^$(2):[[:space:]]*//p' $(1))

define kv_set
_f=$(1) _k=$(2) _v="$(3)"
if grep -q "^$$_k:" $$_f; then
    sed -Ei "s|^$$_k:.*|$$_k: $$_v|" $$_f
else
    printf "%s: %s\n" $$_k "$$_v" >> $$_f
fi
endef

#
# get_rclone_stats() - parse an rclone per-run log and get key/value metrics
# usage: $(call get_rclone_stats,rule_log)
#

define get_rclone_stats
awk '
    function xc(s) { sub(/,$$/,"",s); return s }

    BEGIN { xfer = 0; xfer_new = 0; xfer_replaced = 0; deleted = 0; }

    /^Checks:/                       { checks = $$2 "/" xc($$4) }
    /^Transferred:/ && !/ETA/        { xfer = $$2 "/" xc($$4) }
    /^Transferred:/ && /ETA/         { xfer_size = $$2 $$3 "/" $$5 xc($$6) }
    /Copied \(new\)$$/               { xfer_new++ }
    /Copied \(replaced existing\)$$/ { xfer_replaced++ }
    /^Deleted:/                      { deleted = $$2 }
    /^Elapsed time:/                 { elapsed = $$3 }

    END {
        printf "rclone_checks %s\n",           checks
        printf "rclone_transferred %s\n",      xfer
        printf "rclone_transferred_size %s\n", xfer_size
        printf "rclone_copied_new %s\n",       xfer_new
        printf "rclone_copied_replaced %s\n",  xfer_replaced
        printf "rclone_deleted %s\n",          deleted
        printf "rclone_elapsed %s\n",          elapsed
    }
' $(1)
endef

#
# rclone_stats() - write rclone metrics into the rule stats file and log
# usage: $(call rclone_stats,ruleid,rulef,rule_log)
#

define rclone_stats
declare -A S
while read k v; do
    S[$$k]="$$v"
    $(call kv_set,$(2),$$k,$$v)
done < <($(call get_rclone_stats,$(3)))
printf -v stats_log "checks=%s, transferred=%s (%s) (new=%s, replaced=%s), \
    deleted=%s, elapsed=%s" \
    "$${S[rclone_checks]}" \
    "$${S[rclone_transferred]}" "$${S[rclone_transferred_size]}" \
    "$${S[rclone_copied_new]}" "$${S[rclone_copied_replaced]}" \
    "$${S[rclone_deleted]}" "$${S[rclone_elapsed]}"
$(call log,[$(1)] rclone stats: $$stats_log)
endef

#
# append_rule_log() - append rclone rule log to the main log
# usage: $(call append_rule_log,rule_log)
#

define append_rule_log
{
    printf -- "-- begin rclone log --\n"
    sed '$${/^$$/d}' "$(1)"
    printf -- "-- end rclone log --\n"
} >> $(logf)
endef

#
# trap_on_signal() - signal handler
# usage: $(call trap_on_signal,signal,rc)
#

define trap_on_signal
trap_on_signal() {
    local sig=$$1 sigcode=$$2
    local rc=$$((128 + sigcode))

    $(call log,(WARN) caught $$sig signal)

    t2=$(t);
    rule_ended_at=$(call at,$$t2)
    if [ -n "$$t1" ]; then
        rule_elapsed=$(call t_delta,$$t1,$$t2)
        rule_elapsed_hms_ms=$(call hms_ms,$$rule_elapsed)
    else
        rule_elapsed=
        rule_elapsed_hms_ms=unknown
    fi

    $(call append_rule_log,$$rule_log)
    $(call rclone_stats,$$ruleid,$$rulef,$$rule_log)
    $(call kv_set,$$rulef,rule_ended_at,$$rule_ended_at)
    [ -n "$$rule_elapsed" ] && \
        $(call kv_set,$$rulef,rule_elapsed,$$rule_elapsed)
    $(call kv_set,$$rulef,rc,$$rc)

    $(call kv_set,$(status),program_pid,-)
    $(call kv_set,$(status),rclone_pid,-)
    $(call kv_set,$(status),rc,$$rc)
    $(call log,[$$ruleid] (WARN) end '$(program_name)': rc=$$rc \
        (elapsed: $$rule_elapsed_hms_ms))

    t0=$(call kv_get,$(status),started_at_epoch)
    t3=$(t)
    $(call kv_set,$(status),ended_at,$(call at,$$t3))
    $(call kv_set,$(status),total_elapsed,$(call t_delta,$$t0,$$t3))
    $(call kv_set,$(status),state,NOT RUNNING (interrupted))
    $(call log,end '$(project)' \
        (total elapsed: $(call t_delta_hms_ms,$$t0,$$t3)))

    exit $$rc
}
endef

#-----------------
# report functions
#-----------------

#
# colors() - initialize ansi colors
# usage: $(colors)
#

define colors
ESC="\033"
if [ -t 1 ]; then
    BLD="$$ESC[1m" RST="$$ESC[0m"

    RED="$$ESC[31m" _RED_="$$ESC[91m"
    GRN="$$ESC[32m" _GRN_="$$ESC[92m"
    YEL="$$ESC[33m" _YEL_="$$ESC[93m"
    BLU="$$ESC[34m" _BLU_="$$ESC[94m"
    MAG="$$ESC[35m" _MAG_="$$ESC[95m"
    CYN="$$ESC[36m" _CYN_="$$ESC[96m"
else
    BLD= RST=
    RED= GRN= YEL= BLU= MAG= CYN=
    _RED_= _GRN_= _YEL_= _BLU_= _MAG_= _CYN_=
fi
endef

#
# truncate() - truncate string $(1) to $(2) chars, appending '+' if longer
# usage: truncate
#

define truncate
$$(
    s=$(1) w=$(2)
    len=$$(expr length $$s)
    [ $${#s} -gt $$w ] && printf "%.*s+" $$w $$s || printf $$s
)
endef

#
# mib() - convert rclone size (B, KiB, MiB, GiB, TiB) to MiB (1 decimal)
# usage: $(call mib,size)
#

define mib
$$(awk -v s=$(1) '
    function n(x) { sub(/[BKMGTi]*$$/,"",x); return x }
    BEGIN {
        if      (s ~ /[0-9]B/)   print sprintf("%.1f", n(s)/1048576)
        else if (s ~ /[0-9]KiB/) print sprintf("%.1f", n(s)/1024)
        else if (s ~ /[0-9]MiB/) print sprintf("%.1f", n(s))
        else if (s ~ /[0-9]GiB/) print sprintf("%.1f", n(s)*1024)
        else if (s ~ /[0-9]TiB/) print sprintf("%.1f", n(s)*1048576)
    }
')
endef


# vim: ts=4
