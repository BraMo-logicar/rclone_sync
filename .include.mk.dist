# Name: .include.mk - include for Makefiles
# Usage: include .include.mk
# Author: Marco Broglia <marco.broglia@mutex.it>
# Date: 2025.09.12

#-----
# vars
#-----

# env

SHELL := /usr/bin/bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

# main

home := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))

project      := $(notdir $(home))
program_name := rclone_sync
program_path := $(home)/bin/$(program_name)

hostname := $(shell hostname)
host     := $(shell hostname -s)
ip       := $(shell hostname -I | awk '{ print $$1 }')

# dirs and files

data   := $(home)/data
logf   := $(home)/log/$(project).log
logrun := $(home)/log/run
stats  := $(data)/stats
status := $(stats)/status
tmp    := $(home)/tmp

sizef := $(tmp)/rclone_size.out

# cmds

rclone   := /bin/rclone
sendmail := /sbin/sendmail

# source root and destination prefix

src_root := [SRC_ROOT]
dst_root := [DST_ROOT]

lpath := $(src_root)

remote  := $(project)
bucket  := <BUCKET>
rpath   := $(remote):$(bucket)$(dst_root)

# rclone

rclone_conf := $(home)/etc/rclone.conf
rclone_list := $(home)/etc/rclone.list

# os

fstype := xfs

# stats

runid := $(shell date +%Y%m%d.%H%M%S)

watch_tries := 8
watch_delay := .42

# email

mail_From := $(project) system <MAIL_FROM>
mail_from := <MAIL_FROM>
mail_To   := $(project) admin <MAIL_TO>
mail_to   := <MAIL_TO>

mail_log := yes

# misc

, := ,

#----------
# functions
#----------

#
# now() - current formatted timestamp
# usage: $(now) or $(call now)
#

now = $$(date +'%Y.%m.%d-%H:%M:%S')

#
# t() - current epoch (seconds)
# usage: $(t) or $(call t)
#

t = $$(date +%s.%3N)

#
# elapsed(), since() - elapsed seconds
# elapsed_hms(), since_hms() - elapsed in hms format
# usage: $(call elapsed,t0,t1)
# usage: $(call since,t0)
# usage: $(call elapsed_hms,t0,t1)
# usage: $(call since_hms,t0)
#

elapsed = $$(printf "scale=3; %s - %s\n" $(2) $(1) | bc)
since = $$(printf "scale=3; %s - %s\n" $(call t) $(1) | bc)

hms = $$(awk -v t=$(1) 'BEGIN { \
    s = int(t); \
    ms = 1000 * (t - s); \
    h = int(s / 3600); s %= 3600; \
    m = int(s / 60); s %= 60; \
    if (h > 0) printf("%dh%02dm%02d.%03ds", h, m, s, ms); \
    else if (m > 0) printf("%dm%02d.%03ds", m, s, ms); \
    else printf("%d.%03ds", s, ms) }')

elapsed_hms = $(call hms,$(call elapsed,$(1),$(2)))
since_hms = $(call hms,$(call since,$(1)))

#
# log() - timestamped log
# usage: $(call log,message)
#

make := $(notdir $(MAKE))
log = printf '%s [%s(%s):%s] %s\n' $(now) $(make) $@ $$$$ "$(1)" >> $(logf)

#
# write_stat() - write "key: value" to stat file
# usage: $(call write_stat,statfile,key,value)
#

write_stat = $$(printf "%s: %s\n" "$(2)" "$(3)" >> $(1))

#
# set_status() - write "key: value" to (global) status file
# get_status() - read "key: value" from (global) status file
# usage: $(call set_status,key,value)
# usage: $(call get_status,key)
#

define set_status
_k="$(1)" _v="$(2)"; \
if grep -q "^$$_k:" $(status); then \
    sed -Ei "s|^($$_k):.*|\1: $$_v|" $(status); \
else \
    printf "%s: %s\n" "$$_k" "$$_v" >> $(status); \
fi
endef

get_status = $$(sed -En '/^$(1):/s/^[^:]*:[[:space:]]*//p' $(status))

#
# relpath() - path relative to home
# usage: $(call relpath,path)
#

relpath = $$(printf "%s" $(1) | sed 's|$(home)/||')

#
# mb() - rounded MiB
# usage: $(call mb,bytes)
#

mb = $$((($1 + 524288) / 1048576))

#
# watch_child() - return pid of a child process
# usage: $(call watch_child,ppid,procname,n_iters,sleep)
#

define watch_child
for k in {1..$(3)}; do \
    child=$$(pgrep -P $(1) -x $(2) || true); \
    [ -n "$$child" ] && break; \
    sleep $(4); \
done; \
printf "%s" "$$child"
endef

#
# parse_rule() - parse a rule and set key=value
# usage: $(call parse_rule,rule)
#

define parse_rule
    rule=$$(printf "%s\n" "$(1)"); \
    relpath=$$(printf "%s\n" "$$rule" | awk '{ print $$1 }'); \
    rest=$$(printf "%s\n" "$$rule" | awk '{ $$1 = ""; print }'); \
    ruleid=$${relpath##*/} opts=; \
    set -f; eval "$$rest"; set +f
endef

#
# count_<stat>() - statistics from a per-run log
# usage: $(call count_<stat>,run_log)
#

count_chk = $$(v=$$(awk '/^Checks:/ \
    { print $$2 "/" $$4 }' $(1) | tail -n 1 | tr -d ,); echo $${v:-0})
count_xfer = $$(v=$$(awk '/^Transferred:/ && !/ETA/ \
    { print $$2 "/" $$4 }' $(1) | tail -n 1 | tr -d ,); echo $${v:-0})
count_xfer_sz = $$(v=$$(awk '/^Transferred:/ && /ETA/ \
    { print $$2 $$3 "/" $$5 $$6 }' $(1) | tail -n 1 | tr -d ,); echo $${v:-0})
count_xfer_new = $$(v=$$(grep -c "Copied (new)$$" $(1) \
    2>/dev/null || true); echo $${v:-0})
count_xfer_repl = $$(v=$$(grep -c "Copied (replaced existing)$$" $(1) \
    2>/dev/null || true); echo $${v:-0})
count_del = $$(v=$$(awk '/^Deleted:/ \
    { print $$2 }' $(1) | tail -n 1); echo $${v:-0})
count_elapsed = $$(v=$$(awk '/^Elapsed time:/ \
    { print $$3 }' $(1) | tail -n 1); echo $${v:-0})


# vim: ts=4
