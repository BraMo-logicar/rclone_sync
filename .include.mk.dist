# Name: .include.mk - include for Makefiles
# Usage: include .include.mk
# Author: Marco Broglia <marco.broglia@mutex.it>
# Date: 2025.12.01

#-----
# vars
#-----

# env

SHELL := /usr/bin/bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

# main

home := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))

project      := $(shell basename "$(home)")
version      := 2.0
program_name := rclone_sync
program_path := $(home)/bin/$(program_name)

hostname := $(shell hostname)
host     := $(shell hostname -s)
ip       := $(shell hostname -i)

# cmds

rclone   := /usr/bin/rclone
sendmail := /usr/sbin/sendmail

# rclone

rclone_conf := $(home)/etc/rclone.conf
rclone_ver  := $(shell rclone version | sed -n '1s/.* v//p')

# dirs and files

data    := $(home)/data
tmp     := $(home)/tmp
stats   := $(data)/stats
reports := $(data)/reports

usage  := $(data)/usage
stop   := $(tmp)/stop

logf   := $(home)/log/$(project).log
logrun := $(home)/log/run

# source/destination, local/remote

src_root := [SRC_ROOT]
dst_root := [DST_ROOT]

lpath := $(src_root)

remote := $(project)
bucket := [BUCKET]
rpath  := $(remote):$(bucket)$(dst_root)

# rules

rules_list   := $(home)/etc/rules.list
ruleids_list := $(home)/etc/ruleids.list

# run

watch_tries := 100
watch_delay := .05

# status

last := $(stats)/last
prev := $(stats)/prev

statusf := $(last)/.status

rule_width := [RULE_WIDTH]
rule_queue := [RULE_QUEUE]

# email

mail_From := $(project) system [MAIL_FROM]
mail_from := [MAIL_FROM]
mail_To   := $(project) admin [MAIL_TO]
mail_to   := [MAIL_TO]

mail_log := yes

# colors

esc   := \033

bld   := $(esc)[1m
rst   := $(esc)[0m

red   := $(esc)[31m
grn   := $(esc)[32m
yel   := $(esc)[33m
blu   := $(esc)[34m
mag   := $(esc)[35m
cyn   := $(esc)[36m

_red_ := $(esc)[91m
_grn_ := $(esc)[92m
_yel_ := $(esc)[93m
_blu_ := $(esc)[94m
_mag_ := $(esc)[95m
_cyn_ := $(esc)[96m

# misc

fortytwo := Forty_two_said_Deep_Thought_with_infinite_majesty_and_calm
, := ,

#-----
# time
#-----

#
# t()      - return current epoch (sec.ms)
# t_now()  - return current timestamp (yyyy.mm.dd-hh:mm:ss)
# t_znow() - return current compressed timestamp (yyyymmdd.hhmmss)
# usage: $(t)
# usage: $(t_now)
# usage: $(t_znow)
#

t      = $$(date +%s.%3N)
t_now  = $$(date +%Y.%m.%d-%H:%M:%S)
t_znow = $$(date +%Y%m%d.%H%M%S)

#
# at() - format epoch (sec.ms -> yyyy.mm.dd-hh:mm:ss)
# usage: $(call at,epoch)
#

at = $$(date -d @$$(printf "%.0f" $(1)) +%Y.%m.%d-%H:%M:%S)

#
# t_hms_ms()    - format duration as hms.ms
# t_hms()       - format duration as hms
# t_hms_colon() - format duration as h:m:s
# usage: $(call t_hms_ms,t_delta)
# usage: $(call t_hms,t_delta)
# usage: $(call t_hms_colon,t_delta)
#

define t_hms_ms
$$(
    awk -v t=$(1) '
        BEGIN {
            s = int(t);
            ms = 1000 * (t - s);
            h = int(s / 3600); s %= 3600;
            m = int(s / 60); s %= 60;
            if (h > 0) printf("%dh%02dm%02d.%03ds", h, m, s, ms);
            else if (m > 0) printf("%dm%02d.%03ds", m, s, ms);
            else printf("%d.%03ds", s, ms)
        }'
)
endef

define t_hms
$$(
    awk -v t=$(1) '
        BEGIN {
            s = int(t + .5);
            h = int(s / 3600); s %= 3600;
            m = int(s / 60); s %= 60;
            if (h > 0) printf("%dh%02dm%02ds", h, m, s);
            else if (m > 0) printf("%dm%02ds", m, s);
            else printf("%ds", s)
        }'
)
endef

define t_hms_colon
$$(
    awk -v t=$(1) '
        BEGIN {
            s = int(t + .5);
            h = int(s / 3600); s %= 3600;
            m = int(s / 60); s %= 60;
            printf("%02d:%02d:%02d", h, m, s);
        }'
)
endef

#
# t_delta()        - compute time difference (sec.ms)
# t_delta_hms_ms() - compute time difference (hms.ms)
# t_delta_hms()    - compute time difference (hms)
# usage: $(call t_delta,t0,t1)
# usage: $(call t_delta_hms_ms,t0,t1)
# usage: $(call t_delta_hms,t0,t1)
#

t_delta = $$(awk -v t1=$(1) -v t2=$(2) 'BEGIN { printf("%.3f", t2 - t1) }')
t_delta_hms_ms = $(call t_hms_ms,$(call t_delta,$(1),$(2)))
t_delta_hms = $(call t_hms,$(call t_delta,$(1),$(2)))

#------
# runid
#------

#
# get_runid() - get and validate runid
# usage: $(get_runid)
#

define get_runid
$$(
    case "$${runid-}" in
        "")   runid=$$(kv_get $(statusf) runid) ;;
        prev) [ -L "$(prev)" ] && runid=$$(readlink "$(prev)") ;;
        last) [ -L "$(last)" ] && runid=$$(readlink "$(last)") ;;
    esac

    if [ -d "$(stats)/$$runid" ]; then
        printf "%s" $$runid
        $(call log,[$$runid] runid: '$$runid')
    else
        if [ -t 2 ]; then
            printf "[%s] $${_RED_}invalid runid '%s'$$RST\n" \
                $(project) $$runid >&2
        fi
        $(call log,[$$runid] invalid runid '$$runid')
        exit 1
    fi
)
endef

#---------
# kv store
#---------

#
# define_kv() - define kv_get() and kv_set() shell functions
# kv_set()    - replace key/value (append if missing)
# kv_get()    - get key/value (empty if missing)
# usage: $(define_kv)
#        kv_get file key
#        kv_set file key value
#

define define_kv
kv_set() {
    local f=$$1 k=$$2 v=$$3
    printf -v v "%s" "$$v"
    if grep -q "^$$k:" "$$f"; then
        sed -Ei "s|^$$k:.*|$$k: $$v|" "$$f"
    else
        printf "%s: %s\n" $$k "$$v" >> "$$f"
    fi
}

kv_get() {
    local f=$$1 k=$$2
    sed -En 's/^'$$k':[[:space:]]*//p' "$$f"
}
endef

#--------
# process
#--------

#
# watch_child() - return pid of a child process
# usage: $(call watch_child,ppid,procname,tries,delay)
#

define watch_child
$$(
    for _ in {1..$(3)}; do
        child=$$(pgrep -n -P $(1) -x $(2) || true)
        [ -n "$$child" ] && break
        sleep $(4)
    done
    printf "%s" "$$child"
)
endef

#
# get_command_by_pid() - return command line by pid
# usage: $(call get_command_by_pid,pid)
#

define get_command_by_pid
$$(
    mapfile -d '' -t argv < /proc/$(1)/cmdline
    printf -v cmd "%s " "$${argv[@]}"
    printf "%s" "$${cmd% }"
)
endef

#
# watch_rclone() - discover rclone_pid and rclone_cmd
# usage: $(call watch_rclone,rulef)
#

define watch_rclone
(
    rulef=$(1) tries=$(watch_tries) delay=$(watch_delay)
    rclone_pid=$(call watch_child,$$program_pid,rclone,$$tries,$$delay)
    if [ -n "$$rclone_pid" ]; then
        kv_set "$(statusf)" rclone_pid $$rclone_pid
        rclone_cmd=$(call get_command_by_pid,$$rclone_pid)
        if [ -n "$$rclone_cmd" ]; then
            kv_set "$$rulef" rclone_cmd "$$rclone_cmd"
        fi
    else
        kv_set "$(statusf)" rclone_pid unknown
    fi
) & watcher_pid=$$!
endef

#
# stop_guard() - exit current rule if a stop flag exists
# usage: $(call stop_guard,runid,ruleid)
#

define stop_guard
{
    runid=$(1) ruleid=$(2)
    if [ -f "$(stop)" ]; then
        printf "[%s] stop flag found: exit after current rule \
            (runid=%s, ruleid=%s)\n" $(project) $$runid $ruleid >&2
        rm -f "$(stop)"
        $(call log,[$$runid:$ruleid] stop flag found: \
            exit after current rule (runid=$$runid$(,) ruleid=$ruleid))
        kv_set "$(statusf)" state "NOT RUNNING (stopped)"
        kv_set "$(statusf)" rc 200
        exit 0
    fi
}
endef

#
# define_trap_on_signal() - define trap_on_signal() shell function
# trap_on_signal()        - handle signals
# usage: $(define_trap_on_signal)
#        trap_on_signal signal rc
#

define define_trap_on_signal
trap_on_signal() {
    local sig=$$1 sigcode=$$2
    local rc=$$((128 + sigcode))

    $(call log,[$$runid:$$ruleid] (WARN) caught $$sig signal)

    t2=$(t)
    rule_ended_at=$(call at,$$t2)
    if [ -n "$${t1-}" ]; then
        rule_elapsed=$(call t_delta,$$t1,$$t2)
        rule_elapsed_hms_ms=$(call t_hms_ms,$$rule_elapsed)
    else
        rule_elapsed=
        rule_elapsed_hms_ms=unknown
    fi

    $(call append_rule_log,$$runid,$$ruleid,$$rule_log)
    kv_set "$$rulef" rule_ended_at $$rule_ended_at
    if [ -n "$$rule_elapsed" ]; then
        kv_set "$$rulef" rule_elapsed $$rule_elapsed
    fi
    kv_set "$$rulef" rc $$rc

    kv_set "$(statusf)" program_pid -
    kv_set "$(statusf)" rclone_pid -
    $(call log,[$$runid:$$ruleid] (WARN) end '$(program_name)': rc=$$rc \
        (elapsed: $$rule_elapsed_hms_ms))

    t0=$$(kv_get "$(statusf)" started_at_epoch)
    t3=$(t)
    kv_set "$(statusf)" ended_at_epoch $$t3
    kv_set "$(statusf)" ended_at $(call at,$$t3)
    kv_set "$(statusf)" total_elapsed $(call t_delta,$$t0,$$t3)
    kv_set "$(statusf)" state "NOT RUNNING (killed)"
    kv_set "$(statusf)" rc $$rc

    k=$$(kv_get "$(statusf)" rules_done)
    $(call log,[$$runid] end '$(project)' (runid=$$runid$(,) rules=$$k/$$n) \
        (total elapsed: $(call t_delta_hms_ms,$$t0,$$t3)))
    exit $$rc
}
endef

#------
# rules
#------

#
# define_parse_rule() - define parse_rule() shell function
# parse_rule()        - parse a rule and set key=value
# usage: $(define_parse_rule)
#        parse_rule rule
#

define define_parse_rule
parse_rule() {
    local rule=$$1
    case "$$rule" in
        *" -- "*) path=$${rule%% -- *} opts=$${rule#* -- } ;;
        *)        path=$$rule opts= ;;
    esac
    [ "$$path" = . ] && path=
    ruleid=$$(printf "%s" "$${path##*/}" | tr '[:space:]' '_')
    set -f; eval "$$opts"; set +f
}
endef

#
# count_rules() - count rules in list
# usage: $(count_rules,rules_list)
#

count_rules = $$(grep -Ev '^[[:space:]]*(\#|$$)' "$(1)" | wc -l)

#------
# stats
#------

#
# get_rclone_stats() - parse rclone log and print key/value metrics
# usage: $(call get_rclone_stats,rule_log)
#

define get_rclone_stats
awk '
    function xc(s) { sub(/,$$/, "", s); return s }

    BEGIN { xfer = 0; xfer_new = 0; xfer_replaced = 0; deleted = 0; }

    /^Checks:/                       { checks = $$2 "/" xc($$4) }
    /^Transferred:/ && !/ETA/        { xfer = $$2 "/" xc($$4) }
    /^Transferred:/ && /ETA/         { xfer_size = $$2 $$3 "/" $$5 xc($$6) }
    /Copied \(new\)$$/               { xfer_new++ }
    /Copied \(replaced existing\)$$/ { xfer_replaced++ }
    /^Deleted:/                      { deleted = $$2 }
    /^Elapsed time:/                 { elapsed = $$3 }

    END {
        printf "rclone_checks %s\n",           checks
        printf "rclone_transferred %s\n",      xfer
        printf "rclone_transferred_size %s\n", xfer_size
        printf "rclone_copied_new %d\n",       xfer_new
        printf "rclone_copied_replaced %d\n",  xfer_replaced
        printf "rclone_deleted %d\n",          deleted
        printf "rclone_elapsed %s\n",          elapsed
    }
' "$(1)"
endef

#
# save_rclone_stats() - write rclone metrics to the rule stats file
# usage: $(call save_rclone_stats,runid,ruleid,rulef,rule_log)
#

define save_rclone_stats
declare -A S
while read _k _v; do
    S[$$_k]=$$_v
    kv_set "$(3)" $$_k $$_v
done < <($(call get_rclone_stats,$(4)))
printf -v stats_log "checks=%s, transferred=%s (%s) (new=%d, replaced=%d), \
    deleted=%d, elapsed=%s" \
    "$${S[rclone_checks]}" \
    "$${S[rclone_transferred]}" "$${S[rclone_transferred_size]}" \
    "$${S[rclone_copied_new]}" "$${S[rclone_copied_replaced]}" \
    "$${S[rclone_deleted]}" "$${S[rclone_elapsed]}"
$(call log,[$(1):$(2)] rclone stats: $$stats_log)
endef

#-------
# status
#-------

#
# get_gstate() - compute global state (running|completed|stopped|killed)
# get_rstate() - compute rule state (done|fail|run|queue)
# usage: $(call get_gstate,statusf)
# usage: $(call get_rstate,rulef,gstate)
#

define get_gstate
$$(
    state="$(1)"
    if [ "$$state" = RUNNING ]; then
        printf running
    else
        printf "%s" $$(echo "$$state" | sed 's/.*(\(.*\)).*/\1/')
    fi
)
endef

define get_rstate
$$(
    rulef="$(1)" gstate=$(2)
    if [ ! -f "$$rulef" ]; then
        printf queue
    elif rc=$$(kv_get "$$rulef" rc); [ -n "$$rc" ]; then
        printf done
    elif [ $$gstate = running ]; then
        printf run
    else
        printf fail
    fi
)
endef

#--------
# logging
#--------

#
# log() - write timestamped log
# usage: $(call log,message)
#

make := $(shell basename "$(MAKE)")
log = printf "%s [%s(%s):%d] %s\n" $(t_now) $(make) $@ $$$$ "$(1)" >> "$(logf)"

#
# append_rule_log() - append rclone log to the main log
# usage: $(call append_rule_log,runid,ruleid,rule_log)
#

define append_rule_log
{
    runid=$(1) ruleid=$(2) rule_log=$(3)
    printf -- "-- begin rclone log (runid=%s, ruleid=%s) --\n" $$runid $$ruleid
    sed '$${/^$$/d}' "$$rule_log"
    printf -- "-- end rclone log (runid=%s, ruleid=%s) --\n" $$runid $$ruleid
} >> "$(logf)"
endef

#-----------
# formatting
#-----------

#
# truncate() - truncate string to a max length (chars), append '+' if longer
# usage: $(call truncate,string,width)
#

define truncate
$$(
    s=$(1) w=$(2)
    [ $${#s} -le $$w ] && printf "%s" "$$s" || printf "%s+" "$${s:0:$$((n-1))}"
)
endef

#
# iec2mib() - convert IEC size (B, KiB, MiB, GiB, TiB) to MiB (1 decimal)
# usage: $(call mib,size)
#

define iec2mib
$$(
    awk -v s=$(1) '
        function n(x) { sub(/[BKMGTi]*$$/, "", x); return x }
        BEGIN {
            if      (s ~ /[0-9]B/)   print sprintf("%.1f", n(s) / 1048576)
            else if (s ~ /[0-9]KiB/) print sprintf("%.1f", n(s) / 1024)
            else if (s ~ /[0-9]MiB/) print sprintf("%.1f", n(s))
            else if (s ~ /[0-9]GiB/) print sprintf("%.1f", n(s) * 1024)
            else if (s ~ /[0-9]TiB/) print sprintf("%.1f", n(s) * 1048576)
        }'
)
endef

#
# mib2iec() - convert MiB to best IEC unit (B, KiB, MiB, GiB, TiB) (1 decimal)
# usage: $(call mib2iec,mib)
#

define mib2iec
$$(
    awk -v mib=$(1) '
        BEGIN {
            u = split("B KiB MiB GiB TiB", U)
            n = 1048576 * mib
            for (i = 1; n >= 1024 && i < u; i++) n /= 1024
            printf("%.1f %s", n, U[i])
        }'
)
endef

#
# num3() - format integer with 3-digit grouping
# usage: $(call num3,num)
#

num3 = $$(printf "%s" $(1) | sed -E ':a;s/^(-?[0-9]+)([0-9]{3})/\1'\''\2/;ta')

#------
# email
#------

#
# mime_report() - send multipart email with report and optional log attach
# usage: $(call mime_report,reportf,reportlog)
#

define mime_report
boundary="==$(call random,4)$(fortytwo)==$(call random,4)"
{
    reportf="$(1)" reportlog="$(2)"

    printf "From: %s\n" "$(mail_From)"
    printf "To: %s\n" "$(mail_To)"
    printf "Subject: %s\n" "$$subject"
    printf "MIME-Version: 1.0\n"
    printf "Content-Type: multipart/mixed; boundary=\"%s\"\n" "$$boundary"
    printf "\n'

    printf "--%s\n" "$$boundary"
    printf "Content-Type: text/plain; charset=UTF-8\n"
    printf "Content-Transfer-Encoding: 8bit\n"
    printf "\n"

    cat "$$reportf"

    if [ $(mail_log) = yes ]; then
        printf "\n"
        printf "--%s\n' "$$boundary"
        printf "Content-Type: text/plain; charset=UTF-8; name=\"%s\"\n" \
            "$${reportlog##*/}"
        printf "Content-Transfer-Encoding: 8bit\n"
        printf "Content-Disposition: attachment; filename=\"%s\"\n"
            "$${reportlog##*/}"
        printf "\n"
        cat "$$reportlog"
    fi

    printf "\n"
    printf -- "--%s--\n" "$$boundary"
} | $(sendmail) -i -f $(mail_from) $(mail_to)
endef

#------
# utils
#------

#
# colors() - initialize ansi colors
# usage: $(colors)
#

define colors
if [ -t 1 ]; then
    BLD="$(bld)" RST="$(rst)"

    RED="$(red)" _RED_="$(_red_)"
    GRN="$(grn)" _GRN_="$(_grn_)"
    YEL="$(yel)" _YEL_="$(_yel_)"
    BLU="$(blu)" _BLU_="$(_blu_)"
    MAG="$(mag)" _MAG_="$(_mag_)"
    CYN="$(cyn)" _CYN_="$(_cyn_)"
else
    BLD= RST=
     RED=   GRN=   YEL=   BLU=   MAG=   CYN=
    _RED_= _GRN_= _YEL_= _BLU_= _MAG_= _CYN_=
fi
endef

#
# relpath() - return path relative to home
# usage: $(call relpath,path)
#

relpath = $$(printf "%s" "$(1)" | sed 's|$(home)/||')


# vim: ts=4
