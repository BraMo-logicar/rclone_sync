# Name: .include.mk - include for Makefiles
# Usage: include .include.mk
# Author: Marco Broglia <marco.broglia@mutex.it>
# Date: 2025.10.24

#-----
# vars
#-----

# env

SHELL := /usr/bin/bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

# main

home := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))

project      := $(shell basename "$(home)")
version      := 2.0
program_name := rclone_sync
program_path := $(home)/bin/$(program_name)

hostname := $(shell hostname)
host     := $(shell hostname -s)
ip       := $(shell hostname -I | awk '{ print $$1 }')

# dirs and files

data   := $(home)/data
stats  := $(data)/stats
status := $(data)/status
usage  := $(data)/usage

logf   := $(home)/log/$(project).log
logrun := $(home)/log/run

tmp  := $(home)/tmp
stop := $(tmp)/stop

# cmds

rclone   := /bin/rclone
sendmail := /sbin/sendmail

# source root and destination prefix

src_root := [SRC_ROOT]
dst_root := [DST_ROOT]

lpath := $(src_root)

remote := $(project)
bucket := [BUCKET]
rpath  := $(remote):$(bucket)$(dst_root)

# rclone

rclone_conf := $(home)/etc/rclone.conf
rclone_ver  := $(shell rclone version | sed -n '1s/.* v//p')

# rules

rules_list   := $(home)/etc/rules.list
ruleids_list := $(home)/etc/ruleids.list

# stats

runid := $(shell date +%Y%m%d.%H%M%S)

watch_tries := 100
watch_delay := .05

# report

rule_width := [RULE_WIDTH]
rule_queue := [RULE_QUEUE]

# email

mail_From := $(project) system [MAIL_FROM]
mail_from := [MAIL_FROM]
mail_To   := $(project) admin [MAIL_TO]
mail_to   := [MAIL_TO]

mail_log := yes

# misc

, := ,

#---------------
# core functions
#---------------

#
# t() - current epoch (sec.ms)
# usage: $(t)
#

t = $$(date +%s.%3N)

#
# now() - current timestamp (yyyy.mm.dd-hh:mm:ss)
# usage: $(now)
#

now = $$(date +%Y.%m.%d-%H:%M:%S)

#
# at(epoch) - format an epoch (sec.ms -> yyyy.mm.dd-hh:mm:ss)
# usage: $(call at,epoch)
#

at = $$(date -d @$$(printf "%.0f" $(1)) +%Y.%m.%d-%H:%M:%S)

#
# hms_ms() - format delta times (hms.ms)
# hms() - format delta times (hms)
# hms_colon() - format delta times (h:m:s)
# usage: $(call hms_ms,t_delta)
# usage: $(call hms,t_delta)
# usage: $(call hms_colon,t_delta)
#

define hms_ms
$$(awk -v t=$(1) '
    BEGIN {
        s = int(t);
        ms = 1000 * (t - s);
        h = int(s / 3600); s %= 3600;
        m = int(s / 60); s %= 60;
        if (h > 0) printf("%dh%02dm%02d.%03ds", h, m, s, ms);
        else if (m > 0) printf("%dm%02d.%03ds", m, s, ms);
        else printf("%d.%03ds", s, ms)
    }
')
endef

define hms
$$(awk -v t=$(1) '
    BEGIN {
        s = int(t + .5);
        h = int(s / 3600); s %= 3600;
        m = int(s / 60); s %= 60;
        if (h > 0) printf("%dh%02dm%02ds", h, m, s);
        else if (m > 0) printf("%dm%02ds", m, s);
        else printf("%ds", s)
    }
')
endef

define hms_colon
$$(awk -v t=$(1) '
    BEGIN {
        s = int(t + .5);
        h = int(s / 3600); s %= 3600;
        m = int(s / 60); s %= 60;
        printf("%02d:%02d:%02d", h, m, s);
    }
')
endef

#
# t_delta() - time difference (sec.ms)
# t_delta_hms_ms() - time difference (hms.ms)
# t_delta_hms() - time difference (hms)
# usage: $(call t_delta,t0,t1)
# usage: $(call t_delta_hms_ms,t0,t1)
# usage: $(call t_delta_hms,t0,t1)
#

t_delta = $$(awk -v t1=$(1) -v t2=$(2) 'BEGIN { printf("%.3f", t2 - t1) }')
t_delta_hms_ms = $(call hms_ms,$(call t_delta,$(1),$(2)))
t_delta_hms = $(call hms,$(call t_delta,$(1),$(2)))

#
# log() - timestamped log
# usage: $(call log,message)
#

make := $(shell basename "$(MAKE)")
log = printf "%s [%s(%s):%s] %s\n" $(now) $(make) $@ $$$$ "$(1)" >> "$(logf)"

#
# relpath() - path relative to home
# usage: $(call relpath,path)
#

relpath = $$(printf "%s" "$(1)" | sed 's|$(home)/||')

#
# define_kv() - define kv_get() and kv_set() shell functions
# kv_get()    - get key/value (empty if missing)
# kv_set()    - replace key/value (append if missing)
# usage: $(define_kv)
#        kv_get file key
#        kv_set file key value
#

define define_kv
kv_get() {
    local f=$$1 k=$$2
    sed -En 's/^'$$k':[[:space:]]*//p' "$$f"
}

kv_set() {
    local f=$$1 k=$$2 v=$$3
    printf -v v "%q" "$$v"
    if grep -q "^$$k:" "$$f"; then
        sed -Ei "s|^$$k:.*|$$k: $$v|" "$$f"
    else
        printf "%s: %s\n" $$k "$$v" >> "$$f"
    fi
}
endef

#
# define_parse_rule() - define parse_rule() shell function
# parse_rule()        - parse a rule and set key=value
# usage: $(define_parse_rule)
#        parse_rule rule
#

define define_parse_rule
parse_rule() {
    local rule=$$1
    case "$$rule" in
        *" -- "*) path=$${rule%% -- *} opts=$${rule#* -- } ;;
        *)        path=$$rule opts= ;;
    esac
    [ "$$path" = . ] && path=
    ruleid=$$(printf "%s" "$${path##*/}" | tr '[:space:]' '_')
    set -f; eval "$$opts"; set +f
}
endef

#
# watch_rclone() - discover rclone_pid and rclone_cmd
# usage: $(watch_rclone)
#

define watch_rclone
(
    rclone_pid=$(call
        watch_child,$$program_pid,rclone,$(watch_tries),$(watch_delay))
    if [ -n "$$rclone_pid" ]; then
        kv_set "$(status)" rclone_pid $$rclone_pid
        rclone_cmd=$(call get_command_by_pid,$$rclone_pid)
        if [ -n "$$rclone_cmd" ]; then
            kv_set "$$rulef" rclone_cmd "$$rclone_cmd"
            kv_set "$(status)" rclone_cmd "$$rclone_cmd"
        fi
    else
        kv_set "$(status)" rclone_pid unknown
    fi
) & watcher_pid=$$!
endef

#
# watch_child() - return pid of a child process
# usage: $(call watch_child,ppid,procname,n_iters,sleep)
#

define watch_child
$$(
    for _ in {1..$(3)}; do
        child=$$(pgrep -n -P $(1) -x $(2) || true)
        [ -n "$$child" ] && break
        sleep $(4)
    done
    printf "%s" "$$child"
)
endef

#
# get_command_by_pid() - get command line by pid from /proc
# usage: $(call get_command_by_pid,pid)
#

define get_command_by_pid
$$(
    mapfile -d '' -t argv < /proc/$(1)/cmdline
    printf -v cmd "%q " "$${argv[@]}"
    printf "%s\n" "$${cmd% }"
)
endef

#
# get_rclone_stats() - parse an rclone per-run log and get key/value metrics
# usage: $(call get_rclone_stats,rule_log)
#

define get_rclone_stats
awk '
    function xc(s) { sub(/,$$/,"",s); return s }

    BEGIN { xfer = 0; xfer_new = 0; xfer_replaced = 0; deleted = 0; }

    /^Checks:/                       { checks = $$2 "/" xc($$4) }
    /^Transferred:/ && !/ETA/        { xfer = $$2 "/" xc($$4) }
    /^Transferred:/ && /ETA/         { xfer_size = $$2 $$3 "/" $$5 xc($$6) }
    /Copied \(new\)$$/               { xfer_new++ }
    /Copied \(replaced existing\)$$/ { xfer_replaced++ }
    /^Deleted:/                      { deleted = $$2 }
    /^Elapsed time:/                 { elapsed = $$3 }

    END {
        printf "rclone_checks %s\n",           checks
        printf "rclone_transferred %s\n",      xfer
        printf "rclone_transferred_size %s\n", xfer_size
        printf "rclone_copied_new %s\n",       xfer_new
        printf "rclone_copied_replaced %s\n",  xfer_replaced
        printf "rclone_deleted %s\n",          deleted
        printf "rclone_elapsed %s\n",          elapsed
    }
' "$(1)"
endef

#
# rclone_stats() - write rclone metrics into the rule stats file and log
# usage: $(call rclone_stats,ruleid,rulef,rule_log)
#

define rclone_stats
declare -A S
while read _k _v; do
    S[$$_k]=$$_v
    kv_set "$(2)" $$_k $$_v
done < <($(call get_rclone_stats,$(3)))
printf -v stats_log "checks=%s, transferred=%s (%s) (new=%s, replaced=%s), \
    deleted=%s, elapsed=%s" \
    "$${S[rclone_checks]}" \
    "$${S[rclone_transferred]}" "$${S[rclone_transferred_size]}" \
    "$${S[rclone_copied_new]}" "$${S[rclone_copied_replaced]}" \
    "$${S[rclone_deleted]}" "$${S[rclone_elapsed]}"
$(call log,[$(1)] rclone stats: $$stats_log)
endef

#
# append_rule_log() - append rclone rule log to the main log
# usage: $(call append_rule_log,rule_log)
#

define append_rule_log
{
    printf -- "-- begin rclone log --\n"
    sed '$${/^$$/d}' "$(1)"
    printf -- "-- end rclone log --\n"
} >> "$(logf)"
endef

#
# stop_guard() - exit current rule if a stop flag file exists
# usage: $(stop_guard)
#

define stop_guard
_ruleid=$(1)
if [ -f "$(stop)" ]; then
    printf "[%s] stop flag found: exit after current rule (ruleid='%s')\n" \
        $(project) $$_ruleid
    rm -f "$(stop)"
    $(call log,stop flag found: exit after current rule (ruleid='$$_ruleid'))
    exit 0
fi
endef

#
# define_trap_on_signal() - define trap_on_signal() shell function
# trap_on_signal()        - signal handler
# usage: $(define_trap_on_signal)
#        trap_on_signal signal rc
#

define define_trap_on_signal
trap_on_signal() {
    local sig=$$1 sigcode=$$2
    local rc=$$((128 + sigcode))

    $(call log,(WARN) caught $$sig signal)

    t2=$(t);
    rule_ended_at=$(call at,$$t2)
    if [ -n "$$t1" ]; then
        rule_elapsed=$(call t_delta,$$t1,$$t2)
        rule_elapsed_hms_ms=$(call hms_ms,$$rule_elapsed)
    else
        rule_elapsed=
        rule_elapsed_hms_ms=unknown
    fi

    $(call append_rule_log,$$rule_log)
    $(call rclone_stats,$$ruleid,$$rulef,$$rule_log)
    kv_set "$$rulef" rule_ended_at $$rule_ended_at
    if [ -n "$$rule_elapsed" ]; then
        kv_set "$$rulef" rule_elapsed $$rule_elapsed
    fi
    kv_set "$$rulef" rc $$rc

    kv_set "$(status)" program_pid -
    kv_set "$(status)" rclone_pid -
    kv_set "$(status)" rc $$rc
    $(call log,[$$ruleid] (WARN) end '$(program_name)': rc=$$rc \
        (elapsed: $$rule_elapsed_hms_ms))

    t0=$$(kv_get "$(status)" started_at_epoch)
    t3=$(t)
    kv_set "$(status)" ended_at_epoch $$t3
    kv_set "$(status)" ended_at $(call at,$$t3)
    kv_set "$(status)" total_elapsed $(call t_delta,$$t0,$$t3)
    kv_set "$(status)" state "NOT RUNNING (interrupted)"
    $(call log,end '$(project)' \
        (total elapsed: $(call t_delta_hms_ms,$$t0,$$t3)))

    exit $$rc
}
endef

#-----------------
# report functions
#-----------------

#
# colors() - initialize ansi colors
# usage: $(colors)
#

define colors
ESC="\033"
if [ -t 1 ]; then
    BLD="$$ESC[1m" RST="$$ESC[0m"

    RED="$$ESC[31m" _RED_="$$ESC[91m"
    GRN="$$ESC[32m" _GRN_="$$ESC[92m"
    YEL="$$ESC[33m" _YEL_="$$ESC[93m"
    BLU="$$ESC[34m" _BLU_="$$ESC[94m"
    MAG="$$ESC[35m" _MAG_="$$ESC[95m"
    CYN="$$ESC[36m" _CYN_="$$ESC[96m"
else
    BLD= RST=
    RED= GRN= YEL= BLU= MAG= CYN=
    _RED_= _GRN_= _YEL_= _BLU_= _MAG_= _CYN_=
fi
endef

#
# truncate() - truncate string $(1) to $(2) chars, appending '+' if longer
# usage: $(call truncate,string,width)
#

define truncate
$$(
    s=$(1) w=$(2)
    len=$$(expr length "$$s")
    [ $${#s} -gt $$w ] && printf "%.*s+" $$w "$$s" || printf "$$s"
)
endef

#
# mib() - convert rclone size (B, KiB, MiB, GiB, TiB) to MiB (1 decimal)
# usage: $(call mib,size)
#

define mib
$$(awk -v s=$(1) '
    function n(x) { sub(/[BKMGTi]*$$/,"",x); return x }
    BEGIN {
        if      (s ~ /[0-9]B/)   print sprintf("%.1f", n(s)/1048576)
        else if (s ~ /[0-9]KiB/) print sprintf("%.1f", n(s)/1024)
        else if (s ~ /[0-9]MiB/) print sprintf("%.1f", n(s))
        else if (s ~ /[0-9]GiB/) print sprintf("%.1f", n(s)*1024)
        else if (s ~ /[0-9]TiB/) print sprintf("%.1f", n(s)*1048576)
    }
')
endef


# vim: ts=4
